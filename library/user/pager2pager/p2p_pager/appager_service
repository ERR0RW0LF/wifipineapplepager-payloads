#!/bin/bash
set -euo pipefail

# AP Pager service — monitors APs and queues messages
# Location: /usr/bin/appager (install path)

NETWORKS_FILE="/etc/appager/networks"
MESSAGE_LOG="/etc/appager/message_log.txt"
MESSAGE_REQUESTS="/etc/appager/message_requests.txt"

# 7-bit binary mapping for allowed characters. Values are quoted strings.
declare -A CHAR_TO_BINARY=(
    [" "]="0000000" ["A"]="0000001" ["B"]="0000010" ["C"]="0000011"
    ["D"]="0000100" ["E"]="0000101" ["F"]="0000110" ["G"]="0000111"
    ["H"]="0001000" ["I"]="0001001" ["J"]="0001010" ["K"]="0001011"
    ["L"]="0001100" ["M"]="0001101" ["N"]="0001110" ["O"]="0001111"
    ["P"]="0010000" ["Q"]="0010001" ["R"]="0010010" ["S"]="0010011"
    ["T"]="0010100" ["U"]="0010101" ["V"]="0010110" ["W"]="0010111"
    ["X"]="0011000" ["Y"]="0011001" ["Z"]="0011010" ["a"]="0011011"
    ["b"]="0011100" ["c"]="0011101" ["d"]="0011110" ["e"]="0011111"
    ["f"]="0100000" ["g"]="0100001" ["h"]="0100010" ["i"]="0100011"
    ["j"]="0100100" ["k"]="0100101" ["l"]="0100110" ["m"]="0100111"
    ["n"]="0101000" ["o"]="0101001" ["p"]="0101010" ["q"]="0101011"
    ["r"]="0101100" ["s"]="0101101" ["t"]="0101110" ["u"]="0101111"
    ["v"]="0110000" ["w"]="0110001" ["x"]="0110010" ["y"]="0110011"
    ["z"]="0110100" ["0"]="0110101" ["1"]="0110110" ["2"]="0110111"
    ["3"]="0111000" ["4"]="0111001" ["5"]="0111010" ["6"]="0111011"
    ["7"]="0111100" ["8"]="0111101" ["9"]="0111110"
    ["!"]="0111111" ["@"]="1000000" ["#"]="1000001" ["$"]="1000010"
    ["%"]="1000011" ["^"]="1000100" ["&"]="1000101" ["*"]="1000110"
    ["("]="1000111" [")"]="1001000" ["~"]="1001001" ["<"]="1001010"
    [">"]="1001011" ["+"]="1001100" ["="]="1001101" [":"]="1001110"
    [";"]="1001111" ["["]="1010000" ["]"]="1010001" ["_"]="1010010"
    ['"']="1010011" ['`']="1010100" ["{"]="1010101" ["}"]="1010110"
    ["|"]="1010111" ["\\"]="1011000" [","]="1011001" ["."]="1011010"
    ["-"]="1011011" ["/"]="1011100" ["?"]="1011101"
)

declare -A BINARY_TO_CHAR
for char in "${!CHAR_TO_BINARY[@]}"; do
    BINARY_TO_CHAR[${CHAR_TO_BINARY[$char]}]="$char"
done

# Example message. If you want dynamic messages, populate MESSAGE_REQUESTS and
# change this logic to read from that file (format: <network>::<message>).
encode_msg() {
    local msg="$1"
    local binary_msg=""
    for ((i=0; i<${#msg}; i++)); do
        local char="${msg:$i:1}"
        if [[ -v CHAR_TO_BINARY[$char] ]]; then
            binary_msg+="${CHAR_TO_BINARY[$char]}"
        else
            printf 'Unsupported character in message: %s\n' "$char" >&2
            return 1
        fi
    done

    # Pad to multiple of 8 bits
    local len=${#binary_msg}
    local pad=$(( (8 - (len % 8)) % 8 ))
    if (( pad > 0 )); then
        binary_msg+=$(printf '%*s' "$pad" '' | tr ' ' '0')
    fi

    # Convert to bytes and base64-encode
    local binary_message_base64=$(
        {
            for ((i=0; i<${#binary_msg}; i+=8)); do
                local byte=${binary_msg:i:8}
                local dec=$((2#$byte))
                local hex=$(printf '%02x' "$dec")
                printf '%b' "\\x$hex"
            done
        } | base64
    )

    printf '%s' "$binary_message_base64"
}


# Decodes a message that was encoded with encode_msg
decode_msg() {
    local encoded_msg="$1"
    local binary_msg=""
    local decoded_msg=""

    # Decode base64 to hex
    local binary_data=$(echo "$encoded_msg" | base64 -d 2>/dev/null || {
        printf 'Invalid base64 input\n' >&2
        return 1
    })

    # Convert binary data to string of bits (0001000...)
    # Use C locale to ensure substring indexing is byte-wise (avoid UTF-8 multi-byte issues)
    local len=${#binary_data}
    for ((i=0; i<len; i++)); do
        # Extract the numeric byte value in C locale so we always get 0-255 per byte
        local byte
        byte=$(LC_ALL=C printf '%d' "'${binary_data:$i:1}")

        # Build an 8-bit binary string using bash arithmetic (portable and safe)
        local bits=""
        for ((b=7; b>=0; b--)); do
            bits+=$(( (byte >> b) & 1 ))
        done

        binary_msg+="$bits"
        #printf '%d: byte=%d bits=%s\n' "$i" "$byte" "$bits" >&2
    done
    

    # Print binary of the message for debugging 
    #printf 'Binary message: %s\n' "$binary_msg" >&2

    # Handle padding: trim trailing zeros to make length a multiple of 7
    while (( ${#binary_msg} % 7 != 0 )); do
        binary_msg="${binary_msg::-1}"
        printf 'Trimmed padding, new length: %d\n' "${#binary_msg}" >&2
    done

    #printf 'Binary message after padding removal: %s\n' "$binary_msg" >&2

    # Process each 7-bit chunk
    for ((i=0; i<${#binary_msg}; i+=7)); do
        local chunk=${binary_msg:i:7}
        if [[ -v BINARY_TO_CHAR[$chunk] ]]; then
            decoded_msg+="${BINARY_TO_CHAR[$chunk]}"
        else
            printf 'Invalid binary chunk in message: %s\n' "$chunk" >&2
            return 1
        fi
    done

    printf '%s' "$decoded_msg"
}


MESSAGE="Hello World!"
echo "Original message: $MESSAGE"
echo "Encoded message: $(encode_msg "$MESSAGE")"
echo "Decoded message: $(decode_msg "$(encode_msg "$MESSAGE")")"

# Long message test (to test how much the encoding compresses)
LONG_MESSAGE="The quick brown 1234567890!@#$%^&*()_+"
echo "Original long message: $LONG_MESSAGE"
echo "Length: ${#LONG_MESSAGE} characters"
ENCODED_LONG_MESSAGE=$(encode_msg "$LONG_MESSAGE")
echo "Encoded long message: $ENCODED_LONG_MESSAGE"
echo "Encoded Length: ${#ENCODED_LONG_MESSAGE} characters"
echo "Decoded long message: $(decode_msg "$ENCODED_LONG_MESSAGE")"
echo "Decoded length: $(echo -n "$(decode_msg "$ENCODED_LONG_MESSAGE")" | wc -c) characters"

# Graceful exit on signals
trap 'echo "appager: exiting"; exit 0' INT TERM

while true; do
    # Load configured networks (one per line)
    if [[ -f "$NETWORKS_FILE" ]]; then
        mapfile -t CURRENT_NETWORKS < "$NETWORKS_FILE"
    else
        CURRENT_NETWORKS=()
    fi

    # Gather current SSIDs: prefer _pineap, fallback to iwlist if available
    if command -v _pineap >/dev/null 2>&1; then
        CURRENT_SSIDS=$(_pineap RECON APS 2>/dev/null || true)
    elif command -v iwlist >/dev/null 2>&1; then
        CURRENT_SSIDS=$(iwlist scanning 2>/dev/null | sed -n 's/.*ESSID:"\([^"]*\)".*/\1/p')
    else
        CURRENT_SSIDS=""
    fi

    # For each configured network, check for a match in the scanned SSIDs
    for network in "${CURRENT_NETWORKS[@]}"; do
        # skip empty lines or comments
        [[ -z "$network" || "$network" =~ ^# ]] && continue

        if printf '%s\n' "$CURRENT_SSIDS" | grep -F -q "$network"; then
            # Found a match — queue or log the message. Real behaviour should
            # be implemented here (e.g., write to MESSAGE_REQUESTS or send).
            echo "$(date -Is) Found matching SSID: $network"
            # Example: append a request line (network::message)
            printf '%s::%s\n' "$network" "$MESSAGE" >> "$MESSAGE_REQUESTS" 2>/dev/null || true
        fi
    done

    sleep 5
done